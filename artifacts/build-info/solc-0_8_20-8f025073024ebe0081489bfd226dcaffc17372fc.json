{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-8f025073024ebe0081489bfd226dcaffc17372fc",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/ApprovalManager.sol": "project/contracts/ApprovalManager.sol",
    "contracts/EmergencyGuard.sol": "project/contracts/EmergencyGuard.sol",
    "contracts/TransactionValidator.sol": "project/contracts/TransactionValidator.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "project/contracts/ApprovalManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title ApprovalManager\r\n * @dev Manages and revokes token approvals to prevent exploitation\r\n */\r\ncontract ApprovalManager {\r\n    /// @dev Token approval info\r\n    struct TokenApproval {\r\n        address token;\r\n        address spender;\r\n        uint256 amount;\r\n        uint256 approvedAt;\r\n        bool isActive;\r\n    }\r\n\r\n    /// @dev User's approvals mapping\r\n    mapping(address => TokenApproval[]) public userApprovals;\r\n\r\n    /// @dev Events\r\n    event ApprovalTracked(\r\n        address indexed user,\r\n        address indexed token,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n    event ApprovalRevoked(\r\n        address indexed user,\r\n        address indexed token,\r\n        address indexed spender\r\n    );\r\n\r\n    /**\r\n     * @dev Track a new token approval\r\n     * @param _token The token address\r\n     * @param _spender The spender address\r\n     * @param _amount The approval amount\r\n     */\r\n    function trackApproval(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) public {\r\n        require(_token != address(0), \"Invalid token\");\r\n        require(_spender != address(0), \"Invalid spender\");\r\n\r\n        TokenApproval memory approval = TokenApproval({\r\n            token: _token,\r\n            spender: _spender,\r\n            amount: _amount,\r\n            approvedAt: block.timestamp,\r\n            isActive: true\r\n        });\r\n\r\n        userApprovals[msg.sender].push(approval);\r\n\r\n        emit ApprovalTracked(msg.sender, _token, _spender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Revoke a token approval\r\n     * @param _token The token address\r\n     * @param _spender The spender address\r\n     */\r\n    function revokeApproval(address _token, address _spender) public {\r\n        require(_token != address(0), \"Invalid token\");\r\n        require(_spender != address(0), \"Invalid spender\");\r\n\r\n        TokenApproval[] storage approvals = userApprovals[msg.sender];\r\n\r\n        for (uint256 i = 0; i < approvals.length; i++) {\r\n            if (\r\n                approvals[i].token == _token &&\r\n                approvals[i].spender == _spender &&\r\n                approvals[i].isActive\r\n            ) {\r\n                // Set to inactive instead of deleting\r\n                approvals[i].isActive = false;\r\n\r\n                // Revoke on the actual ERC20 token\r\n                IERC20(_token).approve(_spender, 0);\r\n\r\n                emit ApprovalRevoked(msg.sender, _token, _spender);\r\n                return;\r\n            }\r\n        }\r\n\r\n        revert(\"Approval not found\");\r\n    }\r\n\r\n    /**\r\n     * @dev Get all active approvals for a user\r\n     * @param _user The user address\r\n     * @return Active approvals\r\n     */\r\n    function getUserApprovals(address _user)\r\n        public\r\n        view\r\n        returns (TokenApproval[] memory)\r\n    {\r\n        TokenApproval[] storage allApprovals = userApprovals[_user];\r\n        uint256 activeCount = 0;\r\n\r\n        for (uint256 i = 0; i < allApprovals.length; i++) {\r\n            if (allApprovals[i].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        TokenApproval[] memory activeApprovals = new TokenApproval[](\r\n            activeCount\r\n        );\r\n        uint256 index = 0;\r\n\r\n        for (uint256 i = 0; i < allApprovals.length; i++) {\r\n            if (allApprovals[i].isActive) {\r\n                activeApprovals[index] = allApprovals[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return activeApprovals;\r\n    }\r\n\r\n    /**\r\n     * @dev Get approval count for a user\r\n     * @param _user The user address\r\n     * @return The number of active approvals\r\n     */\r\n    function getApprovalCount(address _user) public view returns (uint256) {\r\n        TokenApproval[] storage allApprovals = userApprovals[_user];\r\n        uint256 activeCount = 0;\r\n\r\n        for (uint256 i = 0; i < allApprovals.length; i++) {\r\n            if (allApprovals[i].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n\r\n        return activeCount;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a specific approval exists for a user\r\n     * @param _user The user address\r\n     * @param _token The token address\r\n     * @param _spender The spender address\r\n     * @return Whether the approval exists and is active\r\n     */\r\n    function hasApproval(\r\n        address _user,\r\n        address _token,\r\n        address _spender\r\n    ) public view returns (bool) {\r\n        TokenApproval[] storage approvals = userApprovals[_user];\r\n\r\n        for (uint256 i = 0; i < approvals.length; i++) {\r\n            if (\r\n                approvals[i].token == _token &&\r\n                approvals[i].spender == _spender &&\r\n                approvals[i].isActive\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n"
      },
      "project/contracts/EmergencyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title EmergencyGuard\r\n * @dev Provides emergency pause/freeze mechanism for wallet protection\r\n */\r\ncontract EmergencyGuard {\r\n    /// @dev User emergency status\r\n    struct EmergencyStatus {\r\n        bool isFrozen;\r\n        uint256 frozenAt;\r\n        string reason;\r\n    }\r\n\r\n    /// @dev Mapping of user addresses to their emergency status\r\n    mapping(address => EmergencyStatus) public emergencyStatus;\r\n\r\n    /// @dev Mapping of user to authorized guardians\r\n    mapping(address => mapping(address => bool)) public guardians;\r\n\r\n    /// @dev Array of all frozen accounts\r\n    address[] public frozenAccounts;\r\n\r\n    /// @dev Events\r\n    event EmergencyActivated(address indexed user, string reason);\r\n    event EmergencyDeactivated(address indexed user);\r\n    event GuardianAdded(address indexed user, address indexed guardian);\r\n    event GuardianRemoved(address indexed user, address indexed guardian);\r\n\r\n    /**\r\n     * @dev Check if an address is frozen\r\n     * @param _account The account to check\r\n     * @return Whether the account is frozen\r\n     */\r\n    function isFrozen(address _account) public view returns (bool) {\r\n        return emergencyStatus[_account].isFrozen;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the freeze status details\r\n     * @param _account The account to check\r\n     * @return status The emergency status struct\r\n     */\r\n    function getEmergencyStatus(address _account)\r\n        public\r\n        view\r\n        returns (EmergencyStatus memory)\r\n    {\r\n        return emergencyStatus[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev User activates emergency mode (freezes their account)\r\n     * @param _reason The reason for emergency activation\r\n     */\r\n    function activateEmergency(string memory _reason) public {\r\n        require(!emergencyStatus[msg.sender].isFrozen, \"Already frozen\");\r\n        require(bytes(_reason).length > 0, \"Reason required\");\r\n\r\n        emergencyStatus[msg.sender] = EmergencyStatus({\r\n            isFrozen: true,\r\n            frozenAt: block.timestamp,\r\n            reason: _reason\r\n        });\r\n\r\n        frozenAccounts.push(msg.sender);\r\n\r\n        emit EmergencyActivated(msg.sender, _reason);\r\n    }\r\n\r\n    /**\r\n     * @dev User deactivates emergency mode (unfreezes their account)\r\n     */\r\n    function deactivateEmergency() public {\r\n        require(emergencyStatus[msg.sender].isFrozen, \"Not frozen\");\r\n\r\n        emergencyStatus[msg.sender].isFrozen = false;\r\n\r\n        emit EmergencyDeactivated(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a guardian to help manage emergency status\r\n     * @param _guardian The guardian address\r\n     */\r\n    function addGuardian(address _guardian) public {\r\n        require(_guardian != address(0), \"Invalid guardian address\");\r\n        require(_guardian != msg.sender, \"Cannot be your own guardian\");\r\n\r\n        guardians[msg.sender][_guardian] = true;\r\n\r\n        emit GuardianAdded(msg.sender, _guardian);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a guardian\r\n     * @param _guardian The guardian address\r\n     */\r\n    function removeGuardian(address _guardian) public {\r\n        guardians[msg.sender][_guardian] = false;\r\n\r\n        emit GuardianRemoved(msg.sender, _guardian);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address is a guardian for a user\r\n     * @param _user The user address\r\n     * @param _guardian The potential guardian address\r\n     * @return Whether the address is a guardian\r\n     */\r\n    function isGuardian(address _user, address _guardian)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return guardians[_user][_guardian];\r\n    }\r\n\r\n    /**\r\n     * @dev Get all frozen accounts (paginated)\r\n     * @param _offset The offset for pagination\r\n     * @param _limit The limit for pagination\r\n     * @return accounts The frozen accounts\r\n     * @return total The total number of frozen accounts\r\n     */\r\n    function getFrozenAccounts(uint256 _offset, uint256 _limit)\r\n        public\r\n        view\r\n        returns (address[] memory accounts, uint256 total)\r\n    {\r\n        total = frozenAccounts.length;\r\n\r\n        if (_offset >= total) {\r\n            return (new address[](0), total);\r\n        }\r\n\r\n        uint256 end = _offset + _limit > total ? total : _offset + _limit;\r\n        uint256 resultLength = end - _offset;\r\n        accounts = new address[](resultLength);\r\n\r\n        for (uint256 i = 0; i < resultLength; i++) {\r\n            accounts[i] = frozenAccounts[_offset + i];\r\n        }\r\n    }\r\n}\r\n"
      },
      "project/contracts/TransactionValidator.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title TransactionValidator\r\n * @dev Validates and analyzes transactions for security risks\r\n */\r\ncontract TransactionValidator {\r\n    /// @dev Validation result\r\n    struct ValidationResult {\r\n        bool isValid;\r\n        uint256 riskScore;\r\n        string riskLevel;\r\n        string[] warnings;\r\n        uint256 validatedAt;\r\n    }\r\n\r\n    /// @dev Validation history\r\n    mapping(address => ValidationResult[]) public validationHistory;\r\n\r\n    /// @dev Suspended accounts (potential threats)\r\n    mapping(address => bool) public suspendedAddresses;\r\n\r\n    /// @dev Events\r\n    event TransactionValidated(\r\n        address indexed user,\r\n        address indexed target,\r\n        uint256 riskScore,\r\n        string riskLevel\r\n    );\r\n    event AddressSuspended(address indexed target, string reason);\r\n    event AddressUnsuspended(address indexed target);\r\n\r\n    /// @dev Risk levels\r\n    string constant RISK_LEVEL_LOW = \"LOW\";\r\n    string constant RISK_LEVEL_MEDIUM = \"MEDIUM\";\r\n    string constant RISK_LEVEL_HIGH = \"HIGH\";\r\n    string constant RISK_LEVEL_CRITICAL = \"CRITICAL\";\r\n\r\n    /**\r\n     * @dev Validate a transaction\r\n     * @param _target The target address of the transaction\r\n     * @param _value The value being sent\r\n     * @param _data The transaction data\r\n     * @return result The validation result\r\n     */\r\n    function validateTransaction(\r\n        address _target,\r\n        uint256 _value,\r\n        bytes calldata _data\r\n    ) public returns (ValidationResult memory result) {\r\n        uint256 riskScore = 0;\r\n        string[] memory warnings = new string[](5);\r\n        uint256 warningCount = 0;\r\n\r\n        // Check if target is suspended\r\n        if (suspendedAddresses[_target]) {\r\n            riskScore += 100;\r\n            warnings[warningCount] = \"Target address is suspended\";\r\n            warningCount++;\r\n        }\r\n\r\n        // Check if target is a contract (basic contract validation)\r\n        if (_target.code.length == 0 && _target != address(0)) {\r\n            // Not a contract, could be an EOA\r\n            // Add minimal risk for EOA transfers\r\n            riskScore += 5;\r\n        }\r\n\r\n        // Check for suspicious function selector patterns\r\n        if (_data.length >= 4) {\r\n            bytes4 selector = bytes4(_data[:4]);\r\n\r\n            // Check for common dangerous function patterns\r\n            // selfdestruct pattern\r\n            if (selector == 0xfe735e99) {\r\n                riskScore += 50;\r\n                warnings[warningCount] = \"Potential selfdestruct function\";\r\n                warningCount++;\r\n            }\r\n\r\n            // delegatecall pattern\r\n            if (selector == 0xf28c5278) {\r\n                riskScore += 40;\r\n                warnings[warningCount] = \"Potential delegatecall function\";\r\n                warningCount++;\r\n            }\r\n        }\r\n\r\n        // Check value for unusually large transfers\r\n        if (_value > 100 ether) {\r\n            riskScore += 20;\r\n            warnings[warningCount] = \"Large value transfer\";\r\n            warningCount++;\r\n        }\r\n\r\n        // Determine risk level\r\n        string memory riskLevel;\r\n        if (riskScore >= 80) {\r\n            riskLevel = RISK_LEVEL_CRITICAL;\r\n        } else if (riskScore >= 50) {\r\n            riskLevel = RISK_LEVEL_HIGH;\r\n        } else if (riskScore >= 20) {\r\n            riskLevel = RISK_LEVEL_MEDIUM;\r\n        } else {\r\n            riskLevel = RISK_LEVEL_LOW;\r\n        }\r\n\r\n        // Build result\r\n        string[] memory finalWarnings = new string[](warningCount);\r\n        for (uint256 i = 0; i < warningCount; i++) {\r\n            finalWarnings[i] = warnings[i];\r\n        }\r\n\r\n        result = ValidationResult({\r\n            isValid: riskScore < 80,\r\n            riskScore: riskScore,\r\n            riskLevel: riskLevel,\r\n            warnings: finalWarnings,\r\n            validatedAt: block.timestamp\r\n        });\r\n\r\n        // Store validation history\r\n        validationHistory[msg.sender].push(result);\r\n\r\n        emit TransactionValidated(msg.sender, _target, riskScore, riskLevel);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Get validation history for a user\r\n     * @param _user The user address\r\n     * @param _limit The number of recent validations to return\r\n     * @return The validation history\r\n     */\r\n    function getValidationHistory(address _user, uint256 _limit)\r\n        public\r\n        view\r\n        returns (ValidationResult[] memory)\r\n    {\r\n        ValidationResult[] storage history = validationHistory[_user];\r\n        uint256 count = history.length > _limit ? _limit : history.length;\r\n\r\n        ValidationResult[] memory result = new ValidationResult[](count);\r\n        uint256 startIndex = history.length - count;\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            result[i] = history[startIndex + i];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Suspend a suspicious address\r\n     * @param _address The address to suspend\r\n     * @param _reason The reason for suspension\r\n     */\r\n    function suspendAddress(address _address, string memory _reason) public {\r\n        require(_address != address(0), \"Invalid address\");\r\n        require(bytes(_reason).length > 0, \"Reason required\");\r\n\r\n        suspendedAddresses[_address] = true;\r\n\r\n        emit AddressSuspended(_address, _reason);\r\n    }\r\n\r\n    /**\r\n     * @dev Unsuspend an address\r\n     * @param _address The address to unsuspend\r\n     */\r\n    function unsuspendAddress(address _address) public {\r\n        require(_address != address(0), \"Invalid address\");\r\n\r\n        suspendedAddresses[_address] = false;\r\n\r\n        emit AddressUnsuspended(_address);\r\n    }\r\n\r\n    /**\r\n     * @dev Check if an address is suspended\r\n     * @param _address The address to check\r\n     * @return Whether the address is suspended\r\n     */\r\n    function isSuspended(address _address) public view returns (bool) {\r\n        return suspendedAddresses[_address];\r\n    }\r\n}\r\n"
      }
    }
  }
}